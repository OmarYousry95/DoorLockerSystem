/***********************************************************************************************
 * [FILE NAME]:		HMI_ECU.c
 * [AUTHOR]:		Omar Yousry
 * [DATE CREATED]:	27 Jan 2020
 * [DESCRIPTION]:	This c file contains application code of Control ECU
 ***********************************************************************************************/

#include "Control_ECU.h"

/*Global array to hold password sent by HMI_ECU*/
uint16 eeprom_addr=0x0311;
//uint8 g_newPassword[PASSWORD_SIZE];
//uint8 g_checkPassword[PASSWORD_SIZE];
uint8 g_eeprom[PASSWORD_SIZE];

uint8 g_functionID=0;
uint8 g_state=0;

/*Configuration structure for Timer1 module:
 * 1. Compare match (CTC) mode
 * 2. Prescalar = 1024 --> T_Timer = 128 usec
 * 3. Initial value = 0
 * 4. Compare value = 39063 --> Interrupt every 5 sec*/
TIMER1_ConfigType Timer1_Config={CTC,F_CPU_1024,0,39063};


void (*func[4])(void)={Control_checkForSavedPassword,Control_setNewPassword,Control_checkNewPassword,
		               Control_receiveAndCheckPassword};

int main()
{
	sei();
	/*Configuration structure for UART module:
	 * 1. Baud rate = 9600
	 * 2. No parity bits is used (parity is disabled)
	 * 3. One stop bit is used
	 * 4. Data frame is 8-bit data*/
	UART_ConfigType UART_Config={9600,NO_PARITY,ONE_STOP_BIT,EIGHT_BITS};

	/*Set callback function for Timer1*/
	TIMER1_setCallBack(fireBuzzerOrOpenDoor);
	/*Initialises UART module with UART_Config structure parameters*/
	UART_init(&UART_Config);

	/*Initialise EEPROM*/
	EEPROM_init();

	/*Set direction of motor pins to be output pins*/
	SET_BIT(DDRB,MOTOR_PIN1);
	SET_BIT(DDRB,MOTOR_PIN2);
	SET_BIT(DDRB,MOTOR_EN);
	/*Set direction of buzzer pin to be output pin*/
	SET_BIT(DDRB,BUZZER);

	while(1)
	{
		/*Call function through pointer to function from the array of pointers to functions*/
		(*func[g_functionID])();
	}
}

/******************************************************************************
 *[Function Name] : Control_checkForSavedPassword
 *[Description]   : This function is the first function to run in Control ECU:
 *					1. It waits until HMI ECU sends a signal for checking if there exists a previously
 *					   saved password or not
 *					2. It checks if there is a saved password in EEPROM or not
 *					3. If not exist, send a NO_SAVED_PASSWORD signal to HMI ECU
 *					4. If exists, send a SAVED_PASSWORD signal to HMI ECU
 *					### g_functionID = 0 ###
 *[Arguments]     : void
 *[Return]        : void
 ******************************************************************************/
void Control_checkForSavedPassword(void)
{
//	uint8 loop_idx=0,count=0;
//	uint8 password[PASSWORD_SIZE];
//	uint8 chkPassword[PASSWORD_SIZE];
	uint8 chkFlag;
	/*Wait until HMI ECU sends CHECK_FOR_SAVED_PASSWORD signal so as to begin checking*/
	while(UART_receiveByte() != CHECK_FOR_SAVED_PASSWORD);
	/*Check if there is a saved password in EEPROM or not*/
	EEPROM_readByte(0x0211,&chkFlag);
	/*No password*/
	if(chkFlag==NO_PASSWORD)
	{
		UART_sendByte(NO_SAVED_PASSWORD);
		/*Go to Control_receiveAndSavePassword function and wait for new password to be sent
		*to save it in EEPROM*/
		g_functionID=1;
	}
	/*Password exists*/
	else
	{
		UART_sendByte(SAVED_PASSWORD);
		/*Go to Control_receiveAndCheckPassword function and wait for password to be checked
		 *with the saved one in EEPROM*/
		g_functionID=3;
	}
//	for(loop_idx=0;loop_idx<PASSWORD_SIZE;loop_idx++)
//	{
//		EEPROM_readByte(eeprom_addr+loop_idx,&password[loop_idx]);
//		EEPROM_readByte((0x0211)+loop_idx,&chkPassword[loop_idx]);
//		if(password[loop_idx] != chkPassword[loop_idx])
//		{
//			count++;
//		}
//	}
//	if(count!=0)
//	{
//		UART_sendByte(NO_SAVED_PASSWORD);
//		/*Go to Control_receiveAndSavePassword function and wait for new password to be sent
//		 *to save it in EEPROM*/
//		g_functionID=1;
//	}
//	else
//	{
////		SET_BIT(DDRD,PD7);
////		SET_BIT(PORTD,PD7);
//		UART_sendByte(SAVED_PASSWORD);
//		/*Go to Control_receiveAndCheckPassword function and wait for password to be checked
//		 *with the saved one in EEPROM*/
//		g_functionID=3;
//	}
}


/******************************************************************************
 *[Function Name] : Control_setNewPassword
 *[Description]   : This function sets a new password for the system
 *					It waits until HMI ECU sends a ready signal then it receives a password
 *					### g_functionID = 1 ###
 *[Arguments]     : void
 *[Return]        : void
 ******************************************************************************/
void Control_setNewPassword(void)
{
	uint8 loop_idx=0;
	/*Wait until HMI ECU sends a ready signal*/
	while(UART_receiveByte()!=HMI_ECU_READY);
	for(loop_idx=0;loop_idx<PASSWORD_SIZE;loop_idx++)
	{
		g_eeprom[loop_idx]=UART_receiveByte();
	}
	/*Go to Control_checkNewPassword function to check if the password is re-entered correctly or not*/
	g_functionID=2;
}

/******************************************************************************
 *[Function Name] : Control_checkNewPassword
 *[Description]   : This function checks the new entered password for the system
 *					1. It waits until HMI ECU sends a ready signal then it receives a password
 *					2. It compares each element of the password to the previously received one
 *					3. If it matches, it sends a CORRECT_NEW_PASSWORD signal to HMI ECU to
 *					   go to main menu options and also goes to wait function
 *					4. It it doesn't match, it Send a NON_CORRECT_NEW_PASSWORD signal to
 *					   HMI ECU to ask user to re-enter password and goes again to Control_setNewPassword
 *					   function
 *					### g_functionID = 2 ###
 *[Arguments]     : void
 *[Return]        : void
 ******************************************************************************/
void Control_checkNewPassword(void)
{
	/*Variable to for loop till password size*/
	uint8 loop_idx=0;
	uint8 password[PASSWORD_SIZE];
	/*Variable used as a flag to check if password matches or not*/
	uint8 trueFlag=0;
	/*Wait until HMI ECU sends a ready signal*/
	while(UART_receiveByte()!=HMI_ECU_READY);
	/*For loop to get a key by key and save it then compares at each time if each
	 *character matches or not*/
	for(loop_idx=0;loop_idx<PASSWORD_SIZE;loop_idx++)
	{
		password[loop_idx]=UART_receiveByte();
		/*For each matching character, increment the trueFlag counter*/
		if(password[loop_idx]==g_eeprom[loop_idx])
		{
			trueFlag++;
		}
	}
	/*Checks for matching between two entered passwords*/
	if(trueFlag==PASSWORD_SIZE)
	{
		/*Send a CORRECT_NEW_PASSWORD signal to HMI ECU to go to main menu options*/
		UART_sendByte(CORRECT_NEW_PASSWORD);
		/*Write the password to EEPROM*/
		for(loop_idx=0;loop_idx<PASSWORD_SIZE;loop_idx++)
		{
			EEPROM_writeByte(eeprom_addr+loop_idx,password[loop_idx]);
		}
		EEPROM_writeByte(0x0211,PASSWORD_EXIST);
		/*Go to Control_receiveAndCheckPassword function*/
		g_functionID=3;
	}
	else
	{
		/*Send a NON_CORRECT_NEW_PASSWORD signal to HMI ECU to ask user to re-enter password*/
		UART_sendByte(NON_CORRECT_NEW_PASSWORD);
		for(loop_idx=0;loop_idx<PASSWORD_SIZE;loop_idx++)
		{
			g_eeprom[loop_idx]=0;
		}
		/*Go again to Control_setNewPassword function to save*/
		g_functionID=1;
	}
}

/******************************************************************************
 *[Function Name] : Control_receiveAndCheckPassword
 *[Description]   : This function receives a password from HMI ECU and compares it with saved one
 *					1. If it matches, it sends to HMI ECU that door is unlocking then door is locking
 *					2. If it doesn't match, it sends to HMI to ask the user to enter it one more time
 *					   Total number of trials = 3
 *					3. If after 3 trials the password doesn't match at any time, it informs the HMI
 *					   ECU to view a thief message and lock the system for 1 minute
 *					### g_functionID = 3 ###
 *[Arguments]     : void
 *[Return]        : void
 ******************************************************************************/
void Control_receiveAndCheckPassword(void)
{
	/*Variable to for loop till password size*/
	uint8 loop_idx=0;
	uint8 check;
	uint8 chkPassword[PASSWORD_SIZE];
	/*Variable used as a flag for mismatches in received password*/
	uint8 mismatch=0;
	static uint8 trial=1;
	/*Busy-wait loop till receiving a ready signal from HMI ECU*/
	while(UART_receiveByte()!= HMI_ECU_READY);
	/*For loop to receive the password character by character and checks if there a mismatch with
	 *the saved one or not*/
	for(loop_idx=0;loop_idx<PASSWORD_SIZE;loop_idx++)
	{
		check=UART_receiveByte();
		EEPROM_readByte(eeprom_addr+loop_idx,&chkPassword[loop_idx]);
		if(check != g_eeprom[loop_idx])
		{
			mismatch++;
		}
	}
	uint8 key = UART_receiveByte();
	if(mismatch == 0)
	{
		g_state=0;
		trial=1;
		if(key == OPEN_DOOR)
		{
			UART_sendByte(CORRECT_PASSWORD);
			/*Open the door*/
			motorRotateClockwise();
			UART_sendByte(DOOR_UNLOCKING);
			TIMER1_init(&Timer1_Config);
		}
		if(key == CHANGE_PASSWORD)
		{
			UART_sendByte(CORRECT_PASSWORD);
			g_functionID=1;
		}
	}
	else
	{
		g_state=1;
		trial++;
		if(trial==4)
		{
			UART_sendByte(THIEF);
			buzzerON();
			TIMER1_init(&Timer1_Config);
		}
		else
		{
			UART_sendByte(WRONG_PASSWORD);
		}
		/*Go again to Control_receiveAndCheckPassword function*/
		g_functionID=3;
	}


}


void buzzerON (void)
{
	SET_BIT(PORTB,BUZZER);
}

void buzzerOFF (void)
{
	CLEAR_BIT(PORTB,BUZZER);
}

void motorRotateClockwise (void)
{
	SET_BIT(PORTB,MOTOR_EN);
	SET_BIT(PORTB,MOTOR_PIN1);
	CLEAR_BIT(PORTB,MOTOR_PIN2);
}

void motorRotateAntiClockwise (void)
{
	SET_BIT(PORTB,MOTOR_EN);
	CLEAR_BIT(PORTB,MOTOR_PIN1);
	SET_BIT(PORTB,MOTOR_PIN2);
}

void motorStop(void)
{
	CLEAR_BIT(PORTB,MOTOR_EN);
	CLEAR_BIT(PORTB,MOTOR_PIN1);
	CLEAR_BIT(PORTB,MOTOR_PIN2);
}

void fireBuzzerOrOpenDoor(void)
{
	static uint8 count=0;
	count++;
	/*When count=3, this means 15 sec time*/
	if(count==3 && g_state==0)
	{
		/*Close the door*/
		motorRotateAntiClockwise();
		UART_sendByte(DOOR_LOCKING);
	}
	/*When count=6, this means 30 sec time*/
	if(count==6 && g_state==0)
	{
		/*Lock the door*/
		motorStop();
		UART_sendByte(DOOR_LOCKED);
		count=0;
		TIMER1_DeInit();
		g_functionID=3;
	}
	/*When count=12, this means 60 sec time i.e. 1 min*/
	if(count==12 && g_state==1)
	{
		buzzerOFF();
		UART_sendByte(SYSTEM_UNLOCKED);
		count=0;
		TIMER1_DeInit();
	}
}
